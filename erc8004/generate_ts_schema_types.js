const fs = require('node:fs');
const path = require('node:path');
const { compile } = require('json-schema-to-typescript');

const SOURCE_ROOT = path.resolve(__dirname, 'spec');
const OUTPUT_FILE = path.resolve(__dirname, './generated/schema-types.ts');
const WRAPPER_NAME = 'SCHEMA_WRAPPER';

async function generate() {
  if (!fs.existsSync(path.dirname(OUTPUT_FILE))) {
    fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
  }

  const properties = {};

  function addSchemasFromDir(baseDir, prefix = '') {
    if (!fs.existsSync(baseDir)) return;

    for (const entry of fs.readdirSync(baseDir, { withFileTypes: true })) {
      const entryPath = path.join(baseDir, entry.name);
      if (entry.isDirectory()) {
        const nextPrefix = prefix ? `${prefix}_${entry.name}` : entry.name;
        addSchemasFromDir(entryPath, nextPrefix);
        continue;
      }

      if (!entry.isFile() || !entry.name.endsWith('.json')) continue;

      const baseName = path.basename(entry.name, '.json');
      const name = `${prefix ? `${prefix}_` : ''}${baseName}`.replace(/-/g, '_');
      properties[name] = { $ref: entryPath };
    }
  }

  addSchemasFromDir(path.join(SOURCE_ROOT, 'schemas'));

  console.log(`Found ${Object.keys(properties).length} schemas. Compiling...`);

  const wrappedSchema = {
    title: WRAPPER_NAME,
    type: 'object',
    properties,
    additionalProperties: false,
  };

  try {
    let ts = await compile(wrappedSchema, WRAPPER_NAME, {
      cwd: SOURCE_ROOT,
      $refOptions: {
        resolve: {
          file: {
            order: 1,
            canRead: true,
            read: (file) => {
              let filePath = file.url;
              if (filePath.startsWith('file://')) {
                try {
                  filePath = require('node:url').fileURLToPath(filePath);
                } catch {
                  filePath = filePath.replace('file://', '');
                }
              }

              const content = fs.readFileSync(filePath, 'utf8');
              const json = JSON.parse(content);

              function clean(obj) {
                if (typeof obj !== 'object' || obj === null) return;
                if (obj.$ref) {
                  delete obj.description;
                  delete obj.title;
                }
                for (const key in obj) {
                  clean(obj[key]);
                }
              }

              clean(json);
              return json;
            },
          },
        },
      },
      bannerComment: `
/* tslint:disable:enforce-comments-on-exported-symbols */
/* eslint-disable */
/* tslint:disable:enforce-name-casing */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
`,
      style: { singleQuote: true, bracketSpacing: true },
      declareExternallyReferenced: true,
      enableConstEnums: false,
      unreachableDefinitions: true,
      strictIndexSignatures: false,
    });

    const wrapperRegex = new RegExp(
      `export interface ${WRAPPER_NAME}\\s*\\{[\\s\\S]*?\\n\\}\\s*`,
      'g'
    );
    ts = ts.replace(wrapperRegex, '').replace(/export interface/g, 'export declare interface');
    ts = ts.replace(/:\\s*\\(([^)]+)\\)\\[\\]/g, ': Array<$1>');
    ts = ts.replace(/:\\s*(\\{[^}]+\\})\\[\\]/g, ': Array<$1>');

    fs.writeFileSync(OUTPUT_FILE, ts.trim());
    console.log(`Success! Types written to ${OUTPUT_FILE}`);
  } catch (err) {
    console.error('Error generating types:', err);
    process.exit(1);
  }
}

generate();
