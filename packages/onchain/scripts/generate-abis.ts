import { existsSync, readFileSync } from "node:fs";
import { mkdir, rename, writeFile } from "node:fs/promises";
import { dirname, resolve } from "node:path";

import { repoRoot } from "@ucp/config/path";

interface ContractSpec {
  name: string;
  artifactPath: string;
  artifactRoot: string;
}

const repoRootDir = repoRoot();
const packageDir = resolve(repoRootDir, "packages", "onchain");
const erc8004OutDir = resolve(repoRootDir, "contracts", "erc8004", "out");
const commercePaymentsOutDir = resolve(
  repoRootDir,
  "contracts",
  "vendor",
  "commerce-payments",
  "out",
);
const outputFile = resolve(packageDir, "src", "contracts", "contracts.ts");

const contracts: ContractSpec[] = [
  {
    name: "IdentityRegistry",
    artifactPath: "IdentityRegistry.sol/IdentityRegistry.json",
    artifactRoot: erc8004OutDir,
  },
  {
    name: "ReputationRegistry",
    artifactPath: "ReputationRegistry.sol/ReputationRegistry.json",
    artifactRoot: erc8004OutDir,
  },
  {
    name: "ValidationRegistry",
    artifactPath: "ValidationRegistry.sol/ValidationRegistry.json",
    artifactRoot: erc8004OutDir,
  },
  {
    name: "AuthCaptureEscrow",
    artifactPath: "AuthCaptureEscrow.sol/AuthCaptureEscrow.json",
    artifactRoot: commercePaymentsOutDir,
  },
  {
    name: "TokenCollector",
    artifactPath: "TokenCollector.sol/TokenCollector.json",
    artifactRoot: commercePaymentsOutDir,
  },
  {
    name: "ERC6492SignatureHandler",
    artifactPath: "ERC6492SignatureHandler.sol/ERC6492SignatureHandler.json",
    artifactRoot: commercePaymentsOutDir,
  },
  {
    name: "ERC3009PaymentCollector",
    artifactPath: "ERC3009PaymentCollector.sol/ERC3009PaymentCollector.json",
    artifactRoot: commercePaymentsOutDir,
  },
  {
    name: "Permit2PaymentCollector",
    artifactPath: "Permit2PaymentCollector.sol/Permit2PaymentCollector.json",
    artifactRoot: commercePaymentsOutDir,
  },
  {
    name: "PreApprovalPaymentCollector",
    artifactPath: "PreApprovalPaymentCollector.sol/PreApprovalPaymentCollector.json",
    artifactRoot: commercePaymentsOutDir,
  },
  {
    name: "SpendPermissionPaymentCollector",
    artifactPath: "SpendPermissionPaymentCollector.sol/SpendPermissionPaymentCollector.json",
    artifactRoot: commercePaymentsOutDir,
  },
  {
    name: "OperatorRefundCollector",
    artifactPath: "OperatorRefundCollector.sol/OperatorRefundCollector.json",
    artifactRoot: commercePaymentsOutDir,
  },
  {
    name: "MockERC3009Token",
    artifactPath: "MockERC3009Token.sol/MockERC3009Token.json",
    artifactRoot: commercePaymentsOutDir,
  },
];

function readFoundryAbi(args: {
  artifactRoot: string;
  artifactPath: string;
}): unknown[] {
  const fullPath = resolve(args.artifactRoot, args.artifactPath);
  if (!existsSync(fullPath)) {
    throw new Error(`Missing Foundry artifact: ${fullPath}`);
  }
  const raw = JSON.parse(readFileSync(fullPath, "utf-8")) as { abi?: unknown };
  if (!raw.abi || !Array.isArray(raw.abi)) {
    throw new Error(`Missing ABI in artifact: ${fullPath}`);
  }
  return raw.abi;
}

function toConstName(contractName: string): string {
  return contractName
    .replace(/([a-z0-9])([A-Z])/g, "$1_$2")
    .toLowerCase()
    .replace(/[^a-z0-9_]/g, "_");
}

function buildOutput(): string {
  const header = [
    "// This file is generated by scripts/generate-abis.ts.",
    "// Do not edit manually.",
    'import type {',
    "  Abi,",
    "  AbiParametersToPrimitiveTypes,",
    "  ExtractAbiEvent,",
    "  ExtractAbiEventNames,",
    '} from "abitype";',
    "",
  ].join("\n");

  const abiBlocks = contracts.map((contract) => {
    const abi = readFoundryAbi({
      artifactRoot: contract.artifactRoot,
      artifactPath: contract.artifactPath,
    });
    const constName = `${toConstName(contract.name)}_abi`;
    const typeName = `${contract.name}Abi`;
    const abiJson = JSON.stringify(abi, null, 2);
    return [
      `export const ${constName} = ${abiJson} as const satisfies Abi;`,
      `export type ${typeName} = typeof ${constName};`,
      "",
    ].join("\n");
  });

  const contractEntries = contracts
    .map((contract) => {
      const constName = `${toConstName(contract.name)}_abi`;
      return `  ${contract.name}: { abi: ${constName} },`;
    })
    .join("\n");

  const footer = [
    "export type EventArgs<",
    "  TAbi extends Abi,",
    "  TEvent extends ExtractAbiEventNames<TAbi>,",
    "> = AbiParametersToPrimitiveTypes<ExtractAbiEvent<TAbi, TEvent>['inputs']>;",
    "",
    "export const contracts = {",
    contractEntries,
    "} as const;",
    "",
  ].join("\n");

  return [header, ...abiBlocks, footer].join("\n");
}

async function writeOutputFile(contents: string): Promise<void> {
  const outDir = dirname(outputFile);
  await mkdir(outDir, { recursive: true });
  const tempFile = `${outputFile}.tmp`;
  await writeFile(tempFile, contents, "utf-8");
  await rename(tempFile, outputFile);
}

async function main(): Promise<void> {
  const output = buildOutput();
  await writeOutputFile(output);
  console.log(`Wrote ${outputFile}`);
}

main().catch((error) => {
  const message = error instanceof Error ? error.message : String(error);
  console.error(message);
  process.exit(1);
});
