import { existsSync, readFileSync, readdirSync } from "node:fs";
import { mkdir, rename, writeFile } from "node:fs/promises";
import { dirname, resolve } from "node:path";

import { repoRoot } from "@ucp/config/path";

interface DeploymentSpec {
  name: string;
  broadcastDir: string;
  contractName: string;
}

const repoRootDir = repoRoot();
const packageDir = resolve(repoRootDir, "packages", "contracts");
const outputFile = resolve(packageDir, "src", "generated", "addresses.ts");

const deployments: DeploymentSpec[] = [
  {
    name: "IdentityRegistry",
    broadcastDir: "contracts/erc8004/broadcast/DeployIdentityRegistry.s.sol",
    contractName: "IdentityRegistry",
  },
  {
    name: "ReputationRegistry",
    broadcastDir: "contracts/erc8004/broadcast/DeployReputationRegistry.s.sol",
    contractName: "ReputationRegistry",
  },
  {
    name: "ValidationRegistry",
    broadcastDir: "contracts/erc8004/broadcast/DeployValidationRegistry.s.sol",
    contractName: "ValidationRegistry",
  },
];

function readDeployAddress(args: {
  broadcastDir: string;
  chainId: number;
  contractName: string;
}): string {
  const runPath = resolve(
    repoRootDir,
    args.broadcastDir,
    String(args.chainId),
    "run-latest.json",
  );
  if (!existsSync(runPath)) {
    throw new Error(`Deploy artifact missing: ${runPath}`);
  }
  const raw = JSON.parse(readFileSync(runPath, "utf-8")) as {
    transactions?: Array<{ contractName?: string; contractAddress?: string }>;
  };
  for (const tx of raw.transactions ?? []) {
    if (tx.contractName === args.contractName && tx.contractAddress) {
      return tx.contractAddress.toLowerCase();
    }
  }
  throw new Error(`No deploy address found for ${args.contractName} in ${runPath}`);
}

function detectChainIds(): number[] {
  const chainIds = new Set<number>();
  for (const deployment of deployments) {
    const absDir = resolve(repoRootDir, deployment.broadcastDir);
    if (!existsSync(absDir)) continue;
    const dirents = readdirSync(absDir, { withFileTypes: true }).filter(
      (dirent) => dirent.isDirectory(),
    );
    for (const dirent of dirents) {
      if (!/^\d+$/.test(dirent.name)) continue;
      chainIds.add(Number(dirent.name));
    }
  }
  return Array.from(chainIds).sort((a, b) => a - b);
}

function buildOutput(): string {
  const chainIds = detectChainIds();
  if (chainIds.length === 0) {
    throw new Error("No chainId directories found in deploy artifacts.");
  }

  const header = [
    "// This file is generated by scripts/generate-addresses.ts.",
    "// Do not edit manually.",
    "",
    "export interface ContractAddressBook {",
    "  [chainId: number]: Record<string, `0x${string}`>;",
    "}",
    "",
  ].join("\n");

  const chainBlocks = chainIds.map((chainId) => {
    const entries = deployments
      .map((deployment) => {
        const address = readDeployAddress({
          broadcastDir: deployment.broadcastDir,
          chainId,
          contractName: deployment.contractName,
        });
        return `    ${deployment.name}: "${address}",`;
      })
      .join("\n");
    return [`  ${chainId}: {`, entries, "  },"].join("\n");
  });

  return [
    header,
    "export const contractAddresses: ContractAddressBook = {",
    ...chainBlocks,
    "};",
    "",
  ].join("\n");
}

async function writeOutputFile(contents: string): Promise<void> {
  const outDir = dirname(outputFile);
  await mkdir(outDir, { recursive: true });
  const tempFile = `${outputFile}.tmp`;
  await writeFile(tempFile, contents, "utf-8");
  await rename(tempFile, outputFile);
}

async function main(): Promise<void> {
  const output = buildOutput();
  await writeOutputFile(output);
  console.log(`Wrote ${outputFile}`);
}

main().catch((error) => {
  const message = error instanceof Error ? error.message : String(error);
  console.error(message);
  process.exit(1);
});
