import { existsSync, readFileSync } from "node:fs";
import { mkdir, rename, writeFile } from "node:fs/promises";
import { dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";

interface ContractSpec {
  name: string;
  artifactPath: string;
}

const scriptsDir = resolve(fileURLToPath(new URL(".", import.meta.url)));
const packageDir = resolve(scriptsDir, "..");
const repoRoot = resolve(packageDir, "..", "..");
const erc8004OutDir = resolve(repoRoot, "contracts", "erc8004", "out");
const outputFile = resolve(packageDir, "src", "generated", "contracts.ts");

const contracts: ContractSpec[] = [
  {
    name: "IdentityRegistry",
    artifactPath: "IdentityRegistry.sol/IdentityRegistry.json",
  },
  {
    name: "ReputationRegistry",
    artifactPath: "ReputationRegistry.sol/ReputationRegistry.json",
  },
  {
    name: "ValidationRegistry",
    artifactPath: "ValidationRegistry.sol/ValidationRegistry.json",
  },
];

function readFoundryAbi(artifactPath: string): unknown[] {
  const fullPath = resolve(erc8004OutDir, artifactPath);
  if (!existsSync(fullPath)) {
    throw new Error(`Missing Foundry artifact: ${fullPath}`);
  }
  const raw = JSON.parse(readFileSync(fullPath, "utf-8")) as { abi?: unknown };
  if (!raw.abi || !Array.isArray(raw.abi)) {
    throw new Error(`Missing ABI in artifact: ${fullPath}`);
  }
  return raw.abi;
}

function toConstName(contractName: string): string {
  return contractName
    .replace(/([a-z0-9])([A-Z])/g, "$1_$2")
    .toLowerCase()
    .replace(/[^a-z0-9_]/g, "_");
}

function buildOutput(): string {
  const header = [
    "// This file is generated by scripts/generate-abis.ts.",
    "// Do not edit manually.",
    'import type {',
    "  Abi,",
    "  AbiParametersToPrimitiveTypes,",
    "  ExtractAbiEvent,",
    "  ExtractAbiEventNames,",
    '} from "abitype";',
    "",
  ].join("\n");

  const abiBlocks = contracts.map((contract) => {
    const abi = readFoundryAbi(contract.artifactPath);
    const constName = `${toConstName(contract.name)}_abi`;
    const typeName = `${contract.name}Abi`;
    const abiJson = JSON.stringify(abi, null, 2);
    return [
      `export const ${constName} = ${abiJson} as const satisfies Abi;`,
      `export type ${typeName} = typeof ${constName};`,
      "",
    ].join("\n");
  });

  const contractEntries = contracts
    .map((contract) => {
      const constName = `${toConstName(contract.name)}_abi`;
      return `  ${contract.name}: { abi: ${constName} },`;
    })
    .join("\n");

  const footer = [
    "export type EventArgs<",
    "  TAbi extends Abi,",
    "  TEvent extends ExtractAbiEventNames<TAbi>,",
    "> = AbiParametersToPrimitiveTypes<ExtractAbiEvent<TAbi, TEvent>['inputs']>;",
    "",
    "export const contracts = {",
    contractEntries,
    "} as const;",
    "",
  ].join("\n");

  return [header, ...abiBlocks, footer].join("\n");
}

async function writeOutputFile(contents: string): Promise<void> {
  const outDir = dirname(outputFile);
  await mkdir(outDir, { recursive: true });
  const tempFile = `${outputFile}.tmp`;
  await writeFile(tempFile, contents, "utf-8");
  await rename(tempFile, outputFile);
}

async function main(): Promise<void> {
  const output = buildOutput();
  await writeOutputFile(output);
  console.log(`Wrote ${outputFile}`);
}

main().catch((error) => {
  const message = error instanceof Error ? error.message : String(error);
  console.error(message);
  process.exit(1);
});
