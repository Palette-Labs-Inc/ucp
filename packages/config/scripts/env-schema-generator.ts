import { readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";

export namespace generateEnvSchemaTemplate {
  export interface Entry {
    comments: string[];
    key: string;
    value: string;
  }

  export interface Options {
    inputPath: string;
    outputPath: string;
    schemaName?: string;
    interfaceName?: string;
  }
}

type EnvSchemaEntry = generateEnvSchemaTemplate.Entry;
type EnvSchemaGeneratorOptions = generateEnvSchemaTemplate.Options;

function isCommentLine(line: string): boolean {
  return line.trimStart().startsWith("#");
}

function stripInlineComment(value: string): string {
  const hashIndex = value.indexOf(" #");
  if (hashIndex === -1) return value;
  return value.slice(0, hashIndex).trimEnd();
}

function unquoteValue(value: string): string {
  const trimmed = value.trim();
  if (
    (trimmed.startsWith('"') && trimmed.endsWith('"')) ||
    (trimmed.startsWith("'") && trimmed.endsWith("'"))
  ) {
    return trimmed.slice(1, -1);
  }
  return trimmed;
}

function parseEnvTemplate(contents: string): EnvSchemaEntry[] {
  const entries: EnvSchemaEntry[] = [];
  const lines = contents.split(/\r?\n/);
  let pendingComments: string[] = [];

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) {
      pendingComments = [];
      continue;
    }
    if (isCommentLine(trimmed)) {
      pendingComments.push(trimmed.replace(/^#+\s?/, ""));
      continue;
    }

    const match = trimmed.match(
      /^(?:export\s+)?([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.*)$/,
    );
    if (!match) {
      pendingComments = [];
      continue;
    }

    const key = match[1];
    const rawValue = stripInlineComment(match[2]);
    const value = unquoteValue(rawValue);

    entries.push({
      comments: pendingComments,
      key,
      value,
    });
    pendingComments = [];
  }

  return entries;
}

function shouldSkipStringDefault(value: string): boolean {
  if (!value) return true;
  if (value.includes("$")) return true;
  return false;
}

function buildZodForValue(value: string): string {
  const normalized = value.trim();
  if (!normalized) return "z.string().optional()";
  if (/^(true|false)$/i.test(normalized)) {
    const defaultValue = normalized.toLowerCase() === "true";
    return `z.coerce.boolean().default(${defaultValue})`;
  }
  if (/^-?\d+$/.test(normalized)) {
    return `z.coerce.number().int().default(${normalized})`;
  }
  if (/^-?\d*\.\d+$/.test(normalized)) {
    return `z.coerce.number().default(${normalized})`;
  }
  if (shouldSkipStringDefault(normalized)) return "z.string().min(1)";
  return `z.string().min(1).default(${JSON.stringify(normalized)})`;
}

function buildSchemaLines(entries: EnvSchemaEntry[]): string[] {
  const lines: string[] = [];

  for (const entry of entries) {
    for (const comment of entry.comments) {
      lines.push(`  // ${comment}`);
    }
    lines.push(`  ${entry.key}: ${buildZodForValue(entry.value)},`);
  }

  return lines;
}

export function generateEnvSchemaTemplate({
  inputPath,
  outputPath,
  schemaName = "BaseEnvSchema",
  interfaceName = "BaseEnv",
}: EnvSchemaGeneratorOptions): void {
  const envTemplate = readFileSync(resolve(inputPath), "utf8");
  const entries = parseEnvTemplate(envTemplate);

  const schemaLines = buildSchemaLines(entries).join("\n");
  const content = `import { z } from "zod";

// Generated by generate-env-schema.ts. Do not edit by hand.
export const ${schemaName} = z.object({
${schemaLines}
});

export interface ${interfaceName} extends z.infer<typeof ${schemaName}> {}
`;

  const outputFile = resolve(outputPath);
  writeFileSync(outputFile, content);
}
