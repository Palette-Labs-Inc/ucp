import { mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, resolve } from "node:path";

import { parseEnvTemplate } from "./env-template.js";

export namespace generateEnvSchemaTemplate {
  export interface Entry {
    comments: string[];
    key: string;
    value: string;
  }

  export interface Options {
    inputPath: string;
    outputPath: string;
    schemaName?: string;
    interfaceName?: string;
  }
}

type EnvSchemaEntry = generateEnvSchemaTemplate.Entry;
type EnvSchemaGeneratorOptions = generateEnvSchemaTemplate.Options;

export interface GenerateEnvSchemaFromTemplatesOptions
  extends Omit<EnvSchemaGeneratorOptions, "inputPath"> {
  templatePaths: string[];
}

function shouldSkipStringDefault(value: string): boolean {
  if (!value) return true;
  if (value.includes("$")) return true;
  return false;
}

function buildZodForValue(value: string): string {
  const normalized = value.trim();
  if (!normalized) return "z.string().optional()";
  if (/^(true|false)$/i.test(normalized)) {
    const defaultValue = normalized.toLowerCase() === "true";
    return `z.coerce.boolean().default(${defaultValue})`;
  }
  if (/^-?\d+$/.test(normalized)) {
    try {
      const asBigInt = BigInt(normalized);
      if (
        asBigInt > BigInt(Number.MAX_SAFE_INTEGER) ||
        asBigInt < BigInt(Number.MIN_SAFE_INTEGER)
      ) {
        return `z.string().min(1).default(${JSON.stringify(normalized)})`;
      }
    } catch {
      return `z.string().min(1).default(${JSON.stringify(normalized)})`;
    }
    return `z.coerce.number().int().default(${normalized})`;
  }
  if (/^-?\d*\.\d+$/.test(normalized)) {
    return `z.coerce.number().default(${normalized})`;
  }
  if (shouldSkipStringDefault(normalized)) return "z.string().min(1)";
  return `z.string().min(1).default(${JSON.stringify(normalized)})`;
}

function buildSchemaLines(entries: EnvSchemaEntry[]): string[] {
  const lines: string[] = [];

  for (const entry of entries) {
    for (const comment of entry.comments) {
      lines.push(`  // ${comment}`);
    }
    lines.push(`  ${entry.key}: ${buildZodForValue(entry.value)},`);
  }

  return lines;
}

function mergeTemplateEntries(
  templates: EnvSchemaEntry[][],
): EnvSchemaEntry[] {
  const entries: EnvSchemaEntry[] = [];
  const indexByKey = new Map<string, number>();

  for (const templateEntries of templates) {
    for (const entry of templateEntries) {
      const index = indexByKey.get(entry.key);
      if (index === undefined) {
        indexByKey.set(entry.key, entries.length);
        entries.push(entry);
        continue;
      }
      entries[index] = entry;
    }
  }

  return entries;
}

function writeSchemaFile(options: {
  entries: EnvSchemaEntry[];
  outputPath: string;
  schemaName: string;
  interfaceName: string;
}): void {
  const schemaLines = buildSchemaLines(options.entries).join("\n");
  const content = `import { z } from "zod";

// Generated by env schema generator. Do not edit by hand.
export const ${options.schemaName} = z.object({
${schemaLines}
});

export interface ${options.interfaceName} extends z.infer<typeof ${options.schemaName}> {}
`;

  const outputFile = resolve(options.outputPath);
  mkdirSync(dirname(outputFile), { recursive: true });
  writeFileSync(outputFile, content);
}

export function generateEnvSchemaTemplate({
  inputPath,
  outputPath,
  schemaName = "BaseEnvSchema",
  interfaceName = "BaseEnv",
}: EnvSchemaGeneratorOptions): void {
  const envTemplate = readFileSync(resolve(inputPath), "utf8");
  const entries = parseEnvTemplate(envTemplate);

  writeSchemaFile({
    entries,
    outputPath,
    schemaName,
    interfaceName,
  });
}

export function generateEnvSchemaFromTemplates({
  templatePaths,
  outputPath,
  schemaName = "EnvSchema",
  interfaceName = "Env",
}: GenerateEnvSchemaFromTemplatesOptions): void {
  const templates = templatePaths.map((templatePath) => {
    const contents = readFileSync(resolve(templatePath), "utf8");
    return parseEnvTemplate(contents);
  });

  const entries = mergeTemplateEntries(templates);

  writeSchemaFile({
    entries,
    outputPath,
    schemaName,
    interfaceName,
  });
}
