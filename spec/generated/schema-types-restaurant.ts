/* tslint:disable:enforce-comments-on-exported-symbols */
/* eslint-disable */
/* tslint:disable:enforce-name-casing */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Matches a specific instrument type based on validation logic.
 */
export type PaymentInstrument = CardPaymentInstrument;
/**
 * A basic card payment instrument with visible card details. Can be inherited by a handler's instrument schema to define handler-specific display details or more complex credential structures.
 */
export type CardPaymentInstrument = PaymentInstrumentBase & {
  /**
   * Indicates this is a card payment instrument.
   */
  type: 'card';
  /**
   * The card brand/network (e.g., visa, mastercard, amex).
   */
  brand: string;
  /**
   * Last 4 digits of the card number.
   */
  last_digits: string;
  /**
   * The month of the card's expiration date (1-12).
   */
  expiry_month?: number;
  /**
   * The year of the card's expiration date.
   */
  expiry_year?: number;
  /**
   * An optional rich text description of the card to display to the user (e.g., 'Visa ending in 1234, expires 12/2025').
   */
  rich_text_description?: string;
  /**
   * An optional URI to a rich image representing the card (e.g., card art provided by the issuer).
   */
  rich_card_art?: string;
  [k: string]: unknown;
};
/**
 * Container for sensitive payment data. Use the specific schema matching the 'type' field.
 */
export type PaymentCredential = TokenCredentialResponse | CardCredential;
/**
 * A fulfillment method for pickup or on-demand delivery in restaurant checkout.
 */
export type RestaurantFulfillmentMethodCreateRequest = {
  /**
   * Fulfillment method type.
   */
  type: 'pickup' | 'on_demand_delivery';
  /**
   * Available destinations. Pickup uses pickup locations; on-demand delivery uses drop off locations.
   */
  destinations?: FulfillmentDestinationRequest[];
  /**
   * ID of the selected destination.
   */
  selected_destination_id?: string | null;
  /**
   * Required delivery inputs for on-demand delivery.
   */
  delivery?: DeliveryQuoteReference | DeliveryInputsRequest;
  [k: string]: unknown;
} & (
  | {
      type?: 'pickup';
      [k: string]: unknown;
    }
  | {
      type?: 'on_demand_delivery';
      [k: string]: unknown;
    }
);
/**
 * A destination for pickup or on-demand delivery in restaurant checkout.
 */
export type FulfillmentDestinationRequest = DropoffLocationRequest | PickupLocationRequest;
/**
 * A dropoff location for on-demand delivery.
 */
export type DropoffLocationRequest = PostalAddress & {
  /**
   * ID specific to this dropoff location.
   */
  id?: string;
  location?: Location;
  [k: string]: unknown;
};
/**
 * A pickup location for on-demand delivery.
 */
export type PickupLocationRequest = PostalAddress & {
  /**
   * ID specific to this pickup location.
   */
  id?: string;
  /**
   * Pickup location name (e.g., store name).
   */
  name?: string;
  location?: Location;
  [k: string]: unknown;
};
/**
 * Capability reference in responses. Only name/version required to confirm active capabilities.
 */
export type CapabilityResponse = Base & {
  [k: string]: unknown;
};
/**
 * Container for error, warning, or info messages.
 */
export type Message = MessageError | MessageWarning | MessageInfo;
/**
 * A fulfillment method for pickup or on-demand delivery in restaurant checkout.
 */
export type RestaurantFulfillmentMethodResponse = {
  /**
   * Unique fulfillment method identifier.
   */
  id: string;
  /**
   * Fulfillment method type.
   */
  type: 'pickup' | 'on_demand_delivery';
  /**
   * Available destinations. Pickup uses pickup locations; on-demand delivery uses drop off locations.
   */
  destinations?: FulfillmentDestinationResponse[];
  /**
   * ID of the selected destination.
   */
  selected_destination_id?: string | null;
  /**
   * Required delivery inputs for on-demand delivery.
   */
  delivery?: DeliveryQuoteReference | DeliveryInputsResponse;
  [k: string]: unknown;
} & (
  | {
      type?: 'pickup';
      [k: string]: unknown;
    }
  | {
      type?: 'on_demand_delivery';
      [k: string]: unknown;
    }
);
/**
 * A destination for pickup or on-demand delivery in restaurant checkout.
 */
export type FulfillmentDestinationResponse = DropoffLocationResponse | PickupLocationResponse;
/**
 * A dropoff location for on-demand delivery.
 */
export type DropoffLocationResponse = PostalAddress & {
  /**
   * ID specific to this dropoff location.
   */
  id: string;
  location?: Location;
  [k: string]: unknown;
};
/**
 * A pickup location for on-demand delivery.
 */
export type PickupLocationResponse = PostalAddress & {
  /**
   * ID specific to this pickup location.
   */
  id: string;
  /**
   * Pickup location name (e.g., store name).
   */
  name?: string;
  location?: Location;
  [k: string]: unknown;
};
/**
 * Order confirmation details for restaurant checkout.
 */
export type RestaurantOrderConfirmation = OrderConfirmation;
/**
 * Location and market context for restaurant operations.
 *
 * This interface was referenced by `MenuCapability`'s JSON-Schema
 * via the `definition` "context".
 *
 * This interface was referenced by `MerchantCapability`'s JSON-Schema
 * via the `definition` "context".
 */
export type RestaurantContext = Context & {
  /**
   * Background context for semantic search (e.g., 'quick lunch nearby', 'family meal under $30').
   */
  intent?: string;
  [k: string]: unknown;
};
/**
 * Append-only fulfillment event for restaurant pickup or on-demand delivery.
 */
export type RestaurantFulfillmentEvent = RestaurantPickupEvent | DeliveryEvent;
/**
 * Webhook payload for restaurant order lifecycle events. This is a snapshot of the full order state plus event metadata; fulfillment.events are part of the order state, not the webhook event itself.
 */
export type RestaurantOrderEvent = RestaurantOrder & {
  /**
   * Unique event identifier.
   */
  event_id: string;
  /**
   * Event creation timestamp in RFC 3339 format.
   */
  created_time: string;
  [k: string]: unknown;
};
/**
 * A fulfillment method for pickup or on-demand delivery in restaurant checkout.
 */
export type RestaurantFulfillmentMethodUpdateRequest = {
  /**
   * Unique fulfillment method identifier.
   */
  id: string;
  /**
   * Available destinations. Pickup uses pickup locations; on-demand delivery uses drop off locations.
   */
  destinations?: FulfillmentDestinationRequest[];
  /**
   * ID of the selected destination.
   */
  selected_destination_id?: string | null;
  /**
   * Required delivery inputs for on-demand delivery.
   */
  delivery?: DeliveryQuoteReference | DeliveryInputsRequest;
  [k: string]: unknown;
} & (
  | {
      type?: 'pickup';
      [k: string]: unknown;
    }
  | {
      type?: 'on_demand_delivery';
      [k: string]: unknown;
    }
);

/**
 * Extends checkout with menu modifier selections for restaurant ordering.
 */
export declare interface CheckoutRestaurantExtensionCreateRequest {
  /**
   * List of line items being checked out.
   */
  line_items: RestaurantLineItemCreateRequest[];
  buyer?: Buyer;
  /**
   * ISO 4217 currency code.
   */
  currency: string;
  payment: PaymentCreateRequest;
  fulfillment?: RestaurantFulfillmentRequest;
  [k: string]: unknown;
}
/**
 * Checkout line item with menu modifier selections.
 */
export declare interface RestaurantLineItemCreateRequest {
  item: MenuItem;
  /**
   * Selected menu modifiers for this line item, including nested selections.
   */
  modifier_selections?: MenuModifierSelection[];
  /**
   * Quantity of the item being purchased.
   */
  quantity: number;
  [k: string]: unknown;
}
/**
 * A configurable menu item with modifier groups.
 *
 * This interface was referenced by `MenuCapability`'s JSON-Schema
 * via the `definition` "menu_item".
 */
export declare interface MenuItem {
  /**
   * Menu item identifier.
   */
  id: string;
  /**
   * Menu item name.
   */
  name: string;
  /**
   * Menu item description in one or more formats. At least one format must be provided.
   */
  description: RichText;
  price: Price;
  /**
   * Menu item media (images, videos, 3D models).
   */
  media?: Media[];
  /**
   * Modifier groups available for this item.
   */
  modifier_groups?: MenuModifierGroup[];
  /**
   * Business-defined custom data extending the menu item model.
   */
  metadata?: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * Text content in one or more formats.
 */
export declare interface RichText {
  /**
   * Plain text.
   */
  plain?: string;
  /**
   * HTML-formatted text.
   */
  html?: string;
  /**
   * Markdown-formatted text.
   */
  markdown?: string;
  [k: string]: unknown;
}
/**
 * Price with explicit currency. Amount is always in minor units (e.g., cents for USD).
 */
export declare interface Price {
  /**
   * Amount in minor currency units (e.g., 1000 = $10.00 USD). Use 0 for free items.
   */
  amount: number;
  /**
   * ISO 4217 currency code (e.g., 'USD', 'EUR', 'GBP').
   */
  currency: string;
  [k: string]: unknown;
}
/**
 * Product media item (image, video, etc.).
 */
export declare interface Media {
  /**
   * Media type discriminator.
   */
  type: 'image' | 'video' | 'model_3d';
  /**
   * URL to the media resource.
   */
  url: string;
  /**
   * Accessibility text describing the media.
   */
  alt_text?: string;
  /**
   * Width in pixels (for images/video).
   */
  width?: number;
  /**
   * Height in pixels (for images/video).
   */
  height?: number;
  [k: string]: unknown;
}
/**
 * Group of modifier options with selection constraints.
 */
export declare interface MenuModifierGroup {
  /**
   * Modifier group identifier.
   */
  id: string;
  /**
   * Display name for the modifier group.
   */
  name: string;
  /**
   * Minimum number of selections required from this group.
   */
  minimum_selections?: number;
  /**
   * Maximum number of selections allowed from this group.
   */
  maximum_selections?: number;
  /**
   * Maximum quantity allowed per modifier option. Defaults to 1 (each modifier can be selected at most once). Set value > 1 to allow per-modifier quantities.
   */
  max_per_modifier?: number;
  /**
   * Available modifier options within this group.
   *
   * @minItems 1
   */
  modifier_options: [MenuModifierOption, ...MenuModifierOption[]];
  /**
   * Modifier group type classification.
   */
  type?: string;
  [k: string]: unknown;
}
/**
 * Selectable option within a modifier group.
 */
export declare interface MenuModifierOption {
  /**
   * Modifier item identifier for this option.
   */
  item_id: string;
  /**
   * Nested modifier groups required after selecting this option.
   */
  child_modifier_groups?: MenuModifierGroup[];
  [k: string]: unknown;
}
/**
 * Selected modifiers for a modifier group, including nested selections.
 */
export declare interface MenuModifierSelection {
  /**
   * Modifier group identifier for this selection.
   */
  modifier_group_id: string;
  /**
   * Selections made within the modifier group.
   */
  selections: MenuModifierItemSelection[];
  [k: string]: unknown;
}
/**
 * Selected modifier item and nested selections within a modifier group.
 */
export declare interface MenuModifierItemSelection {
  /**
   * Selected modifier item identifier.
   */
  item_id: string;
  /**
   * Selected quantity for this modifier option.
   */
  quantity?: number;
  /**
   * Nested modifier selections triggered by this option.
   */
  child_selections?: MenuModifierSelection[];
  [k: string]: unknown;
}
export declare interface Buyer {
  /**
   * First name of the buyer.
   */
  first_name?: string;
  /**
   * Last name of the buyer.
   */
  last_name?: string;
  /**
   * Optional, buyer's full name (if first_name or last_name fields are present they take precedence).
   */
  full_name?: string;
  /**
   * Email of the buyer.
   */
  email?: string;
  /**
   * E.164 standard.
   */
  phone_number?: string;
  [k: string]: unknown;
}
/**
 * Payment configuration containing handlers.
 */
export declare interface PaymentCreateRequest {
  /**
   * The id of the currently selected payment instrument from the instruments array. Set by the agent when submitting payment, and echoed back by the merchant in finalized state.
   */
  selected_instrument_id?: string;
  /**
   * The payment instruments available for this payment. Each instrument is associated with a specific handler via the handler_id field. Handlers can extend the base payment_instrument schema to add handler-specific fields.
   */
  instruments?: PaymentInstrument[];
  [k: string]: unknown;
}
/**
 * The base definition for any payment instrument. It links the instrument to a specific Merchant configuration (handler_id) and defines common fields like billing address.
 */
export declare interface PaymentInstrumentBase {
  /**
   * A unique identifier for this instrument instance, assigned by the Agent. Used to reference this specific instrument in the 'payment.selected_instrument_id' field.
   */
  id: string;
  /**
   * The unique identifier for the handler instance that produced this instrument. This corresponds to the 'id' field in the Payment Handler definition.
   */
  handler_id: string;
  /**
   * The broad category of the instrument (e.g., 'card', 'tokenized_card'). Specific schemas will constrain this to a constant value.
   */
  type: string;
  billing_address?: PostalAddress;
  credential?: PaymentCredential;
  [k: string]: unknown;
}
export declare interface PostalAddress {
  /**
   * An address extension such as an apartment number, C/O or alternative name.
   */
  extended_address?: string;
  /**
   * The street address.
   */
  street_address?: string;
  /**
   * The locality in which the street address is, and which is in the region. For example, Mountain View.
   */
  address_locality?: string;
  /**
   * The region in which the locality is, and which is in the country. Required for applicable countries (i.e. state in US, province in CA). For example, California or another appropriate first-level Administrative division.
   */
  address_region?: string;
  /**
   * The country. Recommended to be in 2-letter ISO 3166-1 alpha-2 format, for example "US". For backward compatibility, a 3-letter ISO 3166-1 alpha-3 country code such as "SGP" or a full country name such as "Singapore" can also be used.
   */
  address_country?: string;
  /**
   * The postal code. For example, 94043.
   */
  postal_code?: string;
  /**
   * Optional. First name of the contact associated with the address.
   */
  first_name?: string;
  /**
   * Optional. Last name of the contact associated with the address.
   */
  last_name?: string;
  /**
   * Optional. Full name of the contact associated with the address (if first_name or last_name fields are present they take precedence).
   */
  full_name?: string;
  /**
   * Optional. Phone number of the contact associated with the address.
   */
  phone_number?: string;
  [k: string]: unknown;
}
/**
 * Base token credential schema. Concrete payment handlers may extend this schema with additional fields and define their own constraints.
 */
export declare interface TokenCredentialResponse {
  /**
   * The specific type of token produced by the handler (e.g., 'stripe_token').
   */
  type: string;
  [k: string]: unknown;
}
/**
 * A card credential containing sensitive payment card details including raw Primary Account Numbers (PANs). This credential type MUST NOT be used for checkout, only with payment handlers that tokenize or encrypt credentials. CRITICAL: Both parties handling CardCredential (sender and receiver) MUST be PCI DSS compliant. Transmission MUST use HTTPS/TLS with strong cipher suites.
 */
export declare interface CardCredential {
  /**
   * The credential type identifier for card credentials.
   */
  type: 'card';
  /**
   * The type of card number. Network tokens are preferred with fallback to FPAN. See PCI Scope for more details.
   */
  card_number_type: 'fpan' | 'network_token' | 'dpan';
  /**
   * Card number.
   */
  number?: string;
  /**
   * The month of the card's expiration date (1-12).
   */
  expiry_month?: number;
  /**
   * The year of the card's expiration date.
   */
  expiry_year?: number;
  /**
   * Cardholder name.
   */
  name?: string;
  /**
   * Card CVC number.
   */
  cvc?: string;
  /**
   * Cryptogram provided with network tokens.
   */
  cryptogram?: string;
  /**
   * Electronic Commerce Indicator / Security Level Indicator provided with network tokens.
   */
  eci_value?: string;
  [k: string]: unknown;
}
/**
 * Container for pickup and on-demand delivery methods in restaurant checkout.
 */
export declare interface RestaurantFulfillmentRequest {
  /**
   * Fulfillment methods for cart items.
   */
  methods?: RestaurantFulfillmentMethodCreateRequest[];
  [k: string]: unknown;
}
/**
 * Geographic coordinates in decimal degrees.
 */
export declare interface Location {
  /**
   * Latitude in decimal degrees.
   */
  lat?: number;
  /**
   * Longitude in decimal degrees.
   */
  lng?: number;
  [k: string]: unknown;
}
/**
 * Reference to a previously created delivery quote.
 */
export declare interface DeliveryQuoteReference {
  /**
   * Delivery quote identifier.
   */
  quote_id: string;
  /**
   * Quote expiration timestamp.
   */
  expires_at?: string;
  [k: string]: unknown;
}
/**
 * Inputs required to create a delivery without a precomputed quote.
 */
export declare interface DeliveryInputsRequest {
  pickup: PickupLocationRequest;
  dropoff: DropoffLocationRequest;
  /**
   * RFC 3339 timestamp when pickup can begin.
   */
  pickup_ready_dt?: string;
  /**
   * RFC 3339 timestamp after which pickup is no longer valid.
   */
  pickup_deadline_dt?: string;
  /**
   * RFC 3339 timestamp when dropoff can begin.
   */
  dropoff_ready_dt?: string;
  /**
   * RFC 3339 timestamp after which dropoff is no longer valid.
   */
  dropoff_deadline_dt?: string;
  items_value: Price;
  /**
   * Optional store identifier for routing or pricing.
   */
  external_store_id?: string;
  /**
   * Optional external identifier for idempotency or correlation.
   */
  external_id?: string;
  [k: string]: unknown;
}
/**
 * Extends checkout with menu modifier selections for restaurant ordering.
 */
export declare interface CheckoutRestaurantExtensionUpdateRequest {
  /**
   * Unique identifier of the checkout session.
   */
  id: string;
  /**
   * List of line items being checked out.
   */
  line_items: RestaurantLineItemUpdateRequest[];
  buyer?: Buyer;
  /**
   * ISO 4217 currency code.
   */
  currency: string;
  payment: PaymentUpdateRequest;
  fulfillment?: RestaurantFulfillmentRequest;
  [k: string]: unknown;
}
/**
 * Checkout line item with menu modifier selections.
 */
export declare interface RestaurantLineItemUpdateRequest {
  id?: string;
  item: MenuItem;
  /**
   * Selected menu modifiers for this line item, including nested selections.
   */
  modifier_selections?: MenuModifierSelection[];
  /**
   * Quantity of the item being purchased.
   */
  quantity: number;
  /**
   * Parent line item identifier for any nested structures.
   */
  parent_id?: string;
  [k: string]: unknown;
}
/**
 * Payment configuration containing handlers.
 */
export declare interface PaymentUpdateRequest {
  /**
   * The id of the currently selected payment instrument from the instruments array. Set by the agent when submitting payment, and echoed back by the merchant in finalized state.
   */
  selected_instrument_id?: string;
  /**
   * The payment instruments available for this payment. Each instrument is associated with a specific handler via the handler_id field. Handlers can extend the base payment_instrument schema to add handler-specific fields.
   */
  instruments?: PaymentInstrument[];
  [k: string]: unknown;
}
/**
 * Extends checkout with menu modifier selections for restaurant ordering.
 */
export declare interface CheckoutRestaurantExtensionResponse {
  ucp: UCPResponseMetadata;
  /**
   * Unique identifier of the checkout session.
   */
  id: string;
  /**
   * List of line items being checked out.
   */
  line_items: RestaurantLineItemResponse[];
  buyer?: Buyer;
  /**
   * Checkout state indicating the current phase and required action. See Checkout Status lifecycle documentation for state transition details.
   */
  status:
    | 'incomplete'
    | 'requires_escalation'
    | 'ready_for_complete'
    | 'complete_in_progress'
    | 'completed'
    | 'canceled';
  /**
   * ISO 4217 currency code.
   */
  currency: string;
  /**
   * Different cart totals.
   */
  totals: TotalResponse[];
  /**
   * List of messages with error and info about the checkout session state.
   */
  messages?: Message[];
  /**
   * Links to be displayed by the platform (Privacy Policy, TOS). Mandatory for legal compliance.
   */
  links: Link[];
  /**
   * RFC 3339 expiry timestamp. Default TTL is 6 hours from creation if not sent.
   */
  expires_at?: string;
  /**
   * URL for checkout handoff and session recovery. MUST be provided when status is requires_escalation. See specification for format and availability requirements.
   */
  continue_url?: string;
  payment: PaymentResponse;
  fulfillment?: RestaurantFulfillmentResponse;
  order?: RestaurantOrderConfirmation;
  [k: string]: unknown;
}
/**
 * Generic UCP envelope for all API responses.
 */
export declare interface UCPResponseMetadata {
  /**
   * UCP protocol version in YYYY-MM-DD format.
   */
  version: string;
  /**
   * Active capabilities for this response.
   */
  capabilities: CapabilityResponse[];
  [k: string]: unknown;
}
export declare interface Base {
  /**
   * Stable capability identifier in reverse-domain notation (e.g., dev.ucp.shopping.checkout). Used in capability negotiation.
   */
  name?: string;
  /**
   * UCP protocol version in YYYY-MM-DD format.
   */
  version?: string;
  /**
   * URL to human-readable specification document.
   */
  spec?: string;
  /**
   * URL to JSON Schema for this capability's payload.
   */
  schema?: string;
  /**
   * Parent capability this extends. Present for extensions, absent for root capabilities.
   */
  extends?: string;
  /**
   * Capability-specific configuration (structure defined by each capability).
   */
  config?: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * Checkout line item with menu modifier selections.
 */
export declare interface RestaurantLineItemResponse {
  id: string;
  item: MenuItem;
  /**
   * Selected menu modifiers for this line item, including nested selections.
   */
  modifier_selections?: MenuModifierSelection[];
  /**
   * Quantity of the item being purchased.
   */
  quantity: number;
  /**
   * Line item totals breakdown.
   */
  totals: TotalResponse[];
  /**
   * Parent line item identifier for any nested structures.
   */
  parent_id?: string;
  [k: string]: unknown;
}
export declare interface TotalResponse {
  /**
   * Type of total categorization.
   */
  type: 'items_discount' | 'subtotal' | 'discount' | 'fulfillment' | 'tax' | 'fee' | 'total';
  /**
   * Text to display against the amount. Should reflect appropriate method (e.g., 'Shipping', 'Delivery').
   */
  display_text?: string;
  /**
   * If type == total, sums subtotal - discount + fulfillment + tax + fee. Should be >= 0. Amount in minor (cents) currency units.
   */
  amount: number;
  [k: string]: unknown;
}
export declare interface MessageError {
  /**
   * Message type discriminator.
   */
  type: 'error';
  /**
   * Error code. Possible values include: missing, invalid, out_of_stock, payment_declined, requires_sign_in, requires_3ds, requires_identity_linking. Freeform codes also allowed.
   */
  code: string;
  /**
   * RFC 9535 JSONPath to the component the message refers to (e.g., $.items[1]).
   */
  path?: string;
  /**
   * Content format, default = plain.
   */
  content_type?: 'plain' | 'markdown';
  /**
   * Human-readable message.
   */
  content: string;
  /**
   * Declares who resolves this error. 'recoverable': agent can fix via API. 'requires_buyer_input': merchant requires information their API doesn't support collecting programmatically (checkout incomplete). 'requires_buyer_review': buyer must authorize before order placement due to policy, regulatory, or entitlement rules (checkout complete). Errors with 'requires_*' severity contribute to 'status: requires_escalation'.
   */
  severity: 'recoverable' | 'requires_buyer_input' | 'requires_buyer_review';
  [k: string]: unknown;
}
export declare interface MessageWarning {
  /**
   * Message type discriminator.
   */
  type: 'warning';
  /**
   * JSONPath (RFC 9535) to related field (e.g., $.line_items[0]).
   */
  path?: string;
  /**
   * Warning code. Machine-readable identifier for the warning type (e.g., final_sale, prop65, fulfillment_changed, age_restricted, etc.).
   */
  code: string;
  /**
   * Human-readable warning message that MUST be displayed.
   */
  content: string;
  /**
   * Content format, default = plain.
   */
  content_type?: 'plain' | 'markdown';
  [k: string]: unknown;
}
export declare interface MessageInfo {
  /**
   * Message type discriminator.
   */
  type: 'info';
  /**
   * RFC 9535 JSONPath to the component the message refers to.
   */
  path?: string;
  /**
   * Info code for programmatic handling.
   */
  code?: string;
  /**
   * Content format, default = plain.
   */
  content_type?: 'plain' | 'markdown';
  /**
   * Human-readable message.
   */
  content: string;
  [k: string]: unknown;
}
export declare interface Link {
  /**
   * Type of link. Well-known values: `privacy_policy`, `terms_of_service`, `refund_policy`, `shipping_policy`, `faq`. Consumers SHOULD handle unknown values gracefully by displaying them using the `title` field or omitting the link.
   */
  type: string;
  /**
   * The actual URL pointing to the content to be displayed.
   */
  url: string;
  /**
   * Optional display text for the link. When provided, use this instead of generating from type.
   */
  title?: string;
  [k: string]: unknown;
}
/**
 * Payment configuration containing handlers.
 */
export declare interface PaymentResponse {
  /**
   * Processing configurations that define how payment instruments can be collected. Each handler specifies a tokenization or payment collection strategy.
   */
  handlers: PaymentHandlerResponse[];
  /**
   * The id of the currently selected payment instrument from the instruments array. Set by the agent when submitting payment, and echoed back by the merchant in finalized state.
   */
  selected_instrument_id?: string;
  /**
   * The payment instruments available for this payment. Each instrument is associated with a specific handler via the handler_id field. Handlers can extend the base payment_instrument schema to add handler-specific fields.
   */
  instruments?: PaymentInstrument[];
  [k: string]: unknown;
}
export declare interface PaymentHandlerResponse {
  /**
   * The unique identifier for this handler instance within the payment.handlers. Used by payment instruments to reference which handler produced them.
   */
  id: string;
  /**
   * The specification name using reverse-DNS format. For example, dev.ucp.delegate_payment.
   */
  name: string;
  /**
   * UCP protocol version in YYYY-MM-DD format.
   */
  version: string;
  /**
   * A URI pointing to the technical specification or schema that defines how this handler operates.
   */
  spec: string;
  /**
   * A URI pointing to a JSON Schema used to validate the structure of the config object.
   */
  config_schema: string;
  instrument_schemas: string[];
  /**
   * A dictionary containing provider-specific configuration details, such as merchant IDs, supported networks, or gateway credentials.
   */
  config: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * Container for pickup and on-demand delivery methods in restaurant checkout.
 */
export declare interface RestaurantFulfillmentResponse {
  /**
   * Fulfillment methods for cart items.
   */
  methods?: RestaurantFulfillmentMethodResponse[];
  /**
   * Availability hints for fulfillment methods.
   */
  available_methods?: RestaurantFulfillmentAvailableMethodResponse[];
  [k: string]: unknown;
}
/**
 * Inputs required to create a delivery without a precomputed quote.
 */
export declare interface DeliveryInputsResponse {
  pickup: PickupLocationResponse;
  dropoff: DropoffLocationResponse;
  /**
   * RFC 3339 timestamp when pickup can begin.
   */
  pickup_ready_dt?: string;
  /**
   * RFC 3339 timestamp after which pickup is no longer valid.
   */
  pickup_deadline_dt?: string;
  /**
   * RFC 3339 timestamp when dropoff can begin.
   */
  dropoff_ready_dt?: string;
  /**
   * RFC 3339 timestamp after which dropoff is no longer valid.
   */
  dropoff_deadline_dt?: string;
  items_value: Price;
  /**
   * Optional store identifier for routing or pricing.
   */
  external_store_id?: string;
  /**
   * Optional external identifier for idempotency or correlation.
   */
  external_id?: string;
  [k: string]: unknown;
}
/**
 * Availability hint for pickup or on-demand delivery in restaurant checkout.
 */
export declare interface RestaurantFulfillmentAvailableMethodResponse {
  /**
   * Fulfillment method type this availability applies to.
   */
  type: 'pickup' | 'on_demand_delivery';
  /**
   * 'now' for immediate availability, or ISO 8601 date for future availability.
   */
  fulfillable_on?: string | null;
  /**
   * Human-readable availability info.
   */
  description?: string;
  [k: string]: unknown;
}
/**
 * Order details available at the time of checkout completion.
 */
export declare interface OrderConfirmation {
  /**
   * Unique order identifier.
   */
  id: string;
  /**
   * Permalink to access the order on merchant site.
   */
  permalink_url: string;
  [k: string]: unknown;
}
/**
 * Menu discovery and configurable menu item definitions.
 */
export declare interface MenuCapability {
  [k: string]: unknown;
}
/**
 * A menu category grouping items for display.
 *
 * This interface was referenced by `MenuCapability`'s JSON-Schema
 * via the `definition` "category".
 */
export declare interface MenuCategory {
  /**
   * Category identifier.
   */
  id: string;
  /**
   * Category display name.
   */
  name: string;
  /**
   * Optional category description.
   */
  description?: string;
  /**
   * Items contained in this category.
   *
   * @minItems 1
   */
  items: [MenuItem, ...MenuItem[]];
  [k: string]: unknown;
}
/**
 * Location and market context. All fields optional. Platforms MAY geo-detect from request; provided fields MUST override.
 */
export declare interface Context {
  /**
   * ISO 3166-1 alpha-2 country code (e.g., 'US', 'CA'). Market context for product availability, pricing, and currency. Detected from request if omitted.
   */
  country?: string;
  /**
   * State, province, emirate, or district (e.g., 'CA', 'ON', 'Dubai'). Format varies by country.
   */
  region?: string;
  /**
   * Postal or ZIP code for regional refinement. Not applicable in all countries.
   */
  postal_code?: string;
  [k: string]: unknown;
}
/**
 * Pagination parameters for requests.
 */
export declare interface Request {
  /**
   * Opaque cursor from previous response.
   */
  cursor?: string;
  /**
   * Maximum number of results to return.
   */
  limit?: number;
  [k: string]: unknown;
}
/**
 * Pagination information in responses.
 */
export declare interface Response {
  /**
   * Cursor to fetch the next page of results.
   */
  cursor?: string;
  /**
   * Whether more results are available.
   */
  has_next_page?: boolean;
  /**
   * Total number of matching items (if available).
   */
  total_count?: number;
  [k: string]: unknown;
}
/**
 * A purchasable modifier item that can be selected within a modifier group.
 */
export declare interface MenuModifierItem {
  /**
   * Modifier item identifier.
   */
  id: string;
  /**
   * Modifier item title.
   */
  title: string;
  price: Price;
  /**
   * Business-defined custom data extending the modifier item model.
   */
  metadata?: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * Merchant search and retrieval capability for menu discovery.
 */
export declare interface MerchantCapability {
  [k: string]: unknown;
}
/**
 * Filter criteria to narrow menu merchant search results. All specified filters combine with AND logic.
 */
export declare interface MenuMerchantSearchFilters {
  /**
   * Filter by merchant category. Categories are merchant-defined strings representing merchant taxonomy.
   */
  category?: string;
  /**
   * Whether the merchant is open at request time.
   */
  open_now?: boolean;
  /**
   * Required fulfillment method type for the merchant.
   */
  fulfillment_method?: 'pickup' | 'on_demand_delivery';
  /**
   * Filter by location using address fields and an optional radius. Partial matches are implementation-defined.
   */
  location?: {
    address?: PostalAddress;
    radius?: Distance;
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * A distance value with a unit.
 */
export declare interface Distance {
  /**
   * Distance value.
   */
  value: number;
  /**
   * Distance unit.
   */
  unit: 'km' | 'mi';
  [k: string]: unknown;
}
/**
 * A merchant available for discovery and restaurant ordering.
 */
export declare interface Merchant {
  /**
   * Global ID (GID) uniquely identifying this merchant.
   */
  id: string;
  /**
   * Merchant display name.
   */
  name: string;
  /**
   * Merchant description in one or more formats. At least one format must be provided.
   */
  description?: RichText;
  /**
   * Canonical merchant page URL.
   */
  url?: string;
  /**
   * Category: taxonomy path (e.g., 'Restaurants > Sushi') or merchant-defined type.
   */
  category?: string;
  /**
   * Merchant media (images, videos). First item is the featured media.
   */
  media?: Media[];
  /**
   * Merchant tags for categorization and search.
   */
  tags?: string[];
  /**
   * Merchant retail locations (stores, pickup points, etc.).
   */
  locations?: RetailLocationResponse[];
  fulfillment_config?: RestaurantMerchantFulfillmentConfig;
  /**
   * Business-defined custom data extending the standard merchant model.
   */
  metadata?: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * A pickup location (retail store, locker, etc.).
 */
export declare interface RetailLocationResponse {
  /**
   * Unique location identifier.
   */
  id: string;
  /**
   * Location name (e.g., store name).
   */
  name: string;
  address?: PostalAddress;
  [k: string]: unknown;
}
/**
 * Merchant fulfillment configuration for restaurant checkout. Method types align with restaurant fulfillment methods.
 */
export declare interface RestaurantMerchantFulfillmentConfig {
  /**
   * Permits multiple destinations per method type.
   */
  allows_multi_destination?: {
    /**
     * Multiple dropoff locations allowed.
     */
    on_demand_delivery?: boolean;
    /**
     * Multiple pickup locations allowed.
     */
    pickup?: boolean;
  };
  /**
   * Allowed method type combinations for a single checkout.
   */
  allows_method_combinations?: Array<'on_demand_delivery' | 'pickup'>[];
  [k: string]: unknown;
}
/**
 * Restaurant order schema with menu modifier selections and pickup/delivery fulfillment events.
 */
export declare interface RestaurantOrder {
  ucp: UCPResponseMetadata;
  /**
   * Unique order identifier.
   */
  id: string;
  /**
   * Associated checkout ID for reconciliation.
   */
  checkout_id: string;
  /**
   * Permalink to access the order on merchant site.
   */
  permalink_url: string;
  /**
   * Immutable line items â€” source of truth for what was ordered.
   */
  line_items: RestaurantOrderLineItem[];
  /**
   * Fulfillment lifecycle events for pickup or on-demand delivery.
   */
  fulfillment: {
    /**
     * Selected fulfillment type for this order.
     */
    type?: 'pickup' | 'on_demand_delivery';
    /**
     * Append-only fulfillment events aligned to the selected fulfillment type.
     */
    events?: RestaurantFulfillmentEvent[];
    [k: string]: unknown;
  };
  /**
   * Append-only event log of money movements (refunds, returns, credits, disputes, cancellations, etc.) that exist independently of fulfillment.
   */
  adjustments?: Adjustment[];
  /**
   * Different totals for the order.
   */
  totals: TotalResponse[];
  [k: string]: unknown;
}
/**
 * Order line item with menu modifier selections.
 */
export declare interface RestaurantOrderLineItem {
  /**
   * Line item identifier.
   */
  id: string;
  item: MenuItem;
  /**
   * Selected menu modifiers for this line item, including nested selections.
   */
  modifier_selections?: MenuModifierSelection[];
  /**
   * Quantity tracking. Values are merchant-calculated and may change as fulfillment progresses.
   */
  quantity: {
    /**
     * Current total quantity.
     */
    total: number;
    /**
     * Quantity fulfilled (sum from fulfillment events).
     */
    fulfilled: number;
    [k: string]: unknown;
  };
  /**
   * Line item totals breakdown.
   */
  totals: TotalResponse[];
  /**
   * Derived status: fulfilled if quantity.fulfilled == quantity.total, partial if quantity.fulfilled > 0, otherwise processing.
   */
  status: 'processing' | 'partial' | 'fulfilled';
  /**
   * Parent line item identifier for any nested structures.
   */
  parent_id?: string;
  [k: string]: unknown;
}
/**
 * Pickup lifecycle event payload for restaurant orders fulfilled via pickup.
 */
export declare interface RestaurantPickupEvent {
  /**
   * Unique pickup event identifier.
   */
  event_id: string;
  /**
   * Pickup lifecycle event type aligned with pickup status values.
   */
  event_type: 'ready' | 'arrived' | 'completed' | 'canceled';
  /**
   * Event creation timestamp in RFC 3339 format.
   */
  created_at: string;
  /**
   * Human-readable description of the pickup status.
   */
  description?: string;
  [k: string]: unknown;
}
/**
 * Delivery lifecycle event payload.
 */
export declare interface DeliveryEvent {
  /**
   * Unique event identifier.
   */
  event_id: string;
  /**
   * Delivery lifecycle event type aligned with delivery status values.
   */
  event_type: 'pending' | 'pickup' | 'pickup_complete' | 'dropoff' | 'delivered' | 'canceled' | 'returned' | 'ongoing';
  /**
   * Event creation timestamp in RFC 3339 format.
   */
  created_at: string;
  delivery: Delivery;
  [k: string]: unknown;
}
/**
 * Standalone delivery resource.
 */
export declare interface Delivery {
  /**
   * Unique delivery identifier.
   */
  id: string;
  /**
   * Delivery status.
   */
  status: 'pending' | 'pickup' | 'pickup_complete' | 'dropoff' | 'delivered' | 'canceled' | 'returned' | 'ongoing';
  /**
   * Quote identifier used to create this delivery.
   */
  quote_id?: string;
  delivery_request?: DeliveryInputsResponse;
  /**
   * Tracking URL for delivery progress.
   */
  tracking_url?: string;
  courier?: Courier;
  /**
   * True when the courier is imminent/near pickup.
   */
  courier_imminent?: boolean;
  /**
   * Delivery creation timestamp.
   */
  created_at?: string;
  /**
   * Delivery update timestamp.
   */
  updated_at?: string;
  [k: string]: unknown;
}
/**
 * Assigned courier details.
 */
export declare interface Courier {
  /**
   * Courier name.
   */
  name?: string;
  /**
   * Courier phone number.
   */
  phone_number?: string;
  /**
   * Courier vehicle type (e.g., car, bike, scooter).
   */
  vehicle_type?: string;
  location?: Location;
  [k: string]: unknown;
}
/**
 * Append-only event that exists independently of fulfillment. Typically represents money movements but can be any post-order change. Polymorphic type that can optionally reference line items.
 */
export declare interface Adjustment {
  /**
   * Adjustment event identifier.
   */
  id: string;
  /**
   * Type of adjustment (open string). Typically money-related like: refund, return, credit, price_adjustment, dispute, cancellation. Can be any value that makes sense for the merchant's business.
   */
  type: string;
  /**
   * RFC 3339 timestamp when this adjustment occurred.
   */
  occurred_at: string;
  /**
   * Adjustment status.
   */
  status: 'pending' | 'completed' | 'failed';
  /**
   * Which line items and quantities are affected (optional).
   */
  line_items?: Array<{
    /**
     * Line item ID reference.
     */
    id: string;
    /**
     * Quantity affected by this adjustment.
     */
    quantity: number;
    [k: string]: unknown;
  }>;
  /**
   * Amount in minor units (cents) for refunds, credits, price adjustments (optional).
   */
  amount?: number;
  /**
   * Human-readable reason or description (e.g., 'Defective item', 'Customer requested').
   */
  description?: string;
  [k: string]: unknown;
}
/**
 * Platform's order capability configuration.
 *
 * This interface was referenced by `RestaurantOrder`'s JSON-Schema
 * via the `definition` "platform_config".
 */
export declare interface PlatformOrderConfig {
  /**
   * URL where merchant sends order lifecycle events (webhooks).
   */
  webhook_url: string;
  [k: string]: unknown;
}
/**
 * Availability hint for pickup or on-demand delivery in restaurant checkout.
 */
export declare interface RestaurantFulfillmentAvailableMethodRequest {
  [k: string]: unknown;
}
/**
 * A menu containing categories and fulfillment configuration.
 */
export declare interface Menu {
  /**
   * Menu identifier.
   */
  id: string;
  /**
   * Menu name.
   */
  name: string;
  /**
   * Category identifiers included in this menu.
   *
   * @minItems 1
   */
  category_ids: [string, ...string[]];
  /**
   * Fulfillment modes supported by this menu.
   */
  fulfillment_modes?: string[];
  /**
   * Menu description.
   */
  description?: string;
  /**
   * Menu availability hours.
   */
  hours?: {
    intervals?: MenuHoursInterval[];
    [k: string]: unknown;
  };
  /**
   * Additional charges applied to orders from this menu.
   */
  additional_charges?: MenuAdditionalCharge[];
  [k: string]: unknown;
}
/**
 * A single menu availability interval for a day of the week.
 */
export declare interface MenuHoursInterval {
  /**
   * Day of week.
   */
  day: string;
  /**
   * Start hour (0-23).
   */
  from_hour: number;
  /**
   * Start minute (0-59).
   */
  from_minute: number;
  /**
   * End hour (0-23).
   */
  to_hour: number;
  /**
   * End minute (0-59).
   */
  to_minute: number;
  [k: string]: unknown;
}
/**
 * An additional charge applied to orders from a menu.
 */
export declare interface MenuAdditionalCharge {
  /**
   * Charge type identifier.
   */
  charge_type?: string;
  flat_charge?: {
    /**
     * ISO 4217 currency code.
     */
    currency_code?: string;
    /**
     * Charge amount in major units.
     */
    amount?: number;
    [k: string]: unknown;
  };
  percentage_charge?: {
    /**
     * Charge percentage as a decimal.
     */
    decimal_value?: number;
    [k: string]: unknown;
  };
  [k: string]: unknown;
}