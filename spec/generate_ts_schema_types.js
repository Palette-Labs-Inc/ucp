const fs = require('node:fs');
const path = require('node:path');
const { compile } = require('json-schema-to-typescript');

const SOURCE_ROOT = path.resolve(__dirname, 'spec');
const OUTPUT_DIR = path.resolve(__dirname, './generated');
const LEGACY_OUTPUT_FILE = path.resolve(OUTPUT_DIR, 'schema-types.ts');
const WRAPPER_NAME = 'SCHEMA_WRAPPER';

/**
 * Dynamically finds all JSON schemas and generates TypeScript types.
 */
function ensureOutputDir() {
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, {recursive: true});
  }
}

function addSchemasFromDir(baseDir, prefix = '', options = {}) {
  const { includeSubdirs = true } = options;
    if (!fs.existsSync(baseDir)) return;

    for (const entry of fs.readdirSync(baseDir, { withFileTypes: true })) {
      const entryPath = path.join(baseDir, entry.name);
      if (entry.isDirectory()) {
        if (!includeSubdirs) continue;
        const nextPrefix = prefix
          ? `${prefix}_${entry.name}`
          : entry.name;
        addSchemasFromDir(entryPath, nextPrefix, options);
        continue;
      }

      if (!entry.isFile() || !entry.name.endsWith('.json')) continue;

      const baseName = path.basename(entry.name, '.json');
      const name = `${prefix ? `${prefix}_` : ''}${baseName}`.replace(/-/g, '_');
      options.properties[name] = { $ref: entryPath };
    }
}

function addHandlerSchemas(handlersDir, properties) {
  if (!fs.existsSync(handlersDir)) return;

  for (const handler of fs.readdirSync(handlersDir)) {
    const handlerPath = path.join(handlersDir, handler);
    if (fs.statSync(handlerPath).isDirectory()) {
      for (const file of fs.readdirSync(handlerPath)) {
        if (file.endsWith('.json')) {
          const name =
              `${handler}_${path.basename(file, '.json')}`.replace(/-/g, '_');
          properties[name] = {$ref: path.join(handlerPath, file)};
        }
      }
    }
  }
}

async function compileDomain(domainName, properties, outputFile) {
  console.log(
      `[${domainName}] Found ${Object.keys(properties).length} schemas. Compiling...`);

  const wrappedSchema = {
    title: WRAPPER_NAME,
    type: 'object',
    properties,
    additionalProperties: false
  };

  try {
    let ts = await compile(wrappedSchema, WRAPPER_NAME, {
      cwd: SOURCE_ROOT,
      $refOptions: {
        resolve: {
          file: {
            order: 1,
            canRead: true,
            read: (file) => {
              let filePath = file.url;
              if (filePath.startsWith('file://')) {
                try {
                  filePath = require('node:url').fileURLToPath(filePath);
                } catch {
                  filePath = filePath.replace('file://', '');
                }
              }

              const content = fs.readFileSync(filePath, 'utf8');
              const json = JSON.parse(content);
              /**
               * Cleans up the JSON object by removing properties that interfere
               * with `json-schema-to-typescript`.
               * This function mutates the input object. While acceptable here,
               * be mindful of side effects. If this JSON object were used
               * elsewhere, this could lead to unexpected behavior.
               * @param {!any} obj The object to clean.
               */
              function clean(obj) {
                if (typeof obj !== 'object' || obj === null) return;

                // When $ref is present, other properties like title and
                // description are technically ignored in older JSON Schema
                // drafts. We remove them here to prevent
                // json-schema-to-typescript from generating duplicate interface
                // definitions or JSDoc comments that conflict with the
                // referenced type.
                if (obj.$ref) {
                  delete obj.description;
                  delete obj.title;
                }

                for (const key in obj) {
                  clean(obj[key]);
                }
              }

              clean(json);
              return json;
            }
          }
        }
      },
      bannerComment: `
/* tslint:disable:enforce-comments-on-exported-symbols */
/* eslint-disable */
/* tslint:disable:enforce-name-casing */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */
`,
      style: {singleQuote: true, bracketSpacing: true},
      declareExternallyReferenced: true,
      enableConstEnums: false,
      unreachableDefinitions: true,
      strictIndexSignatures: false
    });

    // Cleanup: Remove the wrapper interface and convert to 'export declare interface'
    // We use \n} to match the closing brace at the start of a line to avoid matching nested braces
    const wrapperRegex = new RegExp(`export interface ${WRAPPER_NAME}\\s*\\{[\\s\\S]*?\\n\\}\\s*`, 'g');
    ts = ts.replace(wrapperRegex, '')
           .replace(/export interface/g, 'export declare interface');

    // Replace (A | B)[] with Array<A | B>
    ts = ts.replace(/:\s*\(([^)]+)\)\[\]/g, ': Array<$1>');
    // Replace { ... }[] with Array<{ ... }>
    ts = ts.replace(/:\s*(\{[^}]+\})\[\]/g, ': Array<$1>');

    fs.writeFileSync(outputFile, ts.trim());
    console.log(`[${domainName}] Success! Types written to ${outputFile}`);
  } catch (err) {
    console.error(`[${domainName}] Error generating types:`, err);
  }
}

async function generate() {
  ensureOutputDir();

  if (fs.existsSync(LEGACY_OUTPUT_FILE)) {
    fs.unlinkSync(LEGACY_OUTPUT_FILE);
  }

  const domainConfigs = [
    {
      name: 'core',
      output: path.join(OUTPUT_DIR, 'schema-types-core.ts'),
      schemas: [
        {
          dir: path.join(SOURCE_ROOT, 'schemas'),
          prefix: '',
          includeSubdirs: false
        }
      ]
    },
    {
      name: 'shopping',
      output: path.join(OUTPUT_DIR, 'schema-types-shopping.ts'),
      schemas: [
        {
          dir: path.join(SOURCE_ROOT, 'schemas', 'shopping'),
          prefix: 'shopping'
        }
      ]
    },
    {
      name: 'restaurant',
      output: path.join(OUTPUT_DIR, 'schema-types-restaurant.ts'),
      schemas: [
        {
          dir: path.join(SOURCE_ROOT, 'schemas', 'restaurant'),
          prefix: 'restaurant'
        }
      ]
    },
    {
      name: 'delivery',
      output: path.join(OUTPUT_DIR, 'schema-types-delivery.ts'),
      schemas: [
        {
          dir: path.join(SOURCE_ROOT, 'schemas', 'delivery'),
          prefix: 'delivery'
        }
      ]
    },
    {
      name: 'discovery',
      output: path.join(OUTPUT_DIR, 'schema-types-discovery.ts'),
      schemas: [
        {
          dir: path.join(SOURCE_ROOT, 'discovery'),
          prefix: 'discovery'
        }
      ]
    },
    {
      name: 'handlers',
      output: path.join(OUTPUT_DIR, 'schema-types-handlers.ts'),
      handlers: path.join(SOURCE_ROOT, 'handlers')
    }
  ];

  for (const config of domainConfigs) {
    const properties = {};

    if (config.schemas) {
      for (const schemaConfig of config.schemas) {
        addSchemasFromDir(schemaConfig.dir, schemaConfig.prefix, {
          includeSubdirs: schemaConfig.includeSubdirs,
          properties
        });
      }
    }

    if (config.handlers) {
      addHandlerSchemas(config.handlers, properties);
    }

    await compileDomain(config.name, properties, config.output);
  }
}

generate();
